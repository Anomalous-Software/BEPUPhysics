using System;
using System.Collections.Generic;
using BEPUphysics.BroadPhaseSystems;
using BEPUphysics.Constraints;
using BEPUphysics.NarrowPhaseSystems.Pairs;
using BEPUphysics.SolverSystems;
using BEPUphysics.Threading;
using BEPUphysics.CollisionRuleManagement;
using System.Collections.ObjectModel;
using BEPUphysics.DataStructures;

namespace BEPUphysics.NarrowPhaseSystems
{
    ///<summary>
    /// Pair of types.
    ///</summary>
    public struct TypePair : IEquatable<TypePair>
    {
        //Currently this requires some reflective labor.  If perhaps the broad phase entries had some sort of 'id'... and they simply return that int through the interface.
        //Could be 'faster' assuming the supporting logic that creates the ids to begin with isn't too obtuse.
        ///<summary>
        /// First type in the pair.
        ///</summary>
        public Type A;

        ///<summary>
        /// Second type in the pair.
        ///</summary>
        public Type B;

        ///<summary>
        /// Constructs a new type pair.
        ///</summary>
        ///<param name="a">First type in the pair.</param>
        ///<param name="b">Second type in the pair.</param>
        public TypePair(Type a, Type b)
        {
            A = a;
            B = b;
        }

        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer that is the hash code for this instance.
        /// </returns>
        /// <filterpriority>2</filterpriority>
        public override int GetHashCode()
        {
            //TODO: Use old hash code system?
            return A.GetHashCode() + B.GetHashCode();
        }


        #region IEquatable<TypePair> Members

        /// <summary>
        /// Indicates whether the current object is equal to another object of the same type.
        /// </summary>
        /// <returns>
        /// true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
        /// </returns>
        /// <param name="other">An object to compare with this object.</param>
        public bool Equals(TypePair other)
        {
            return (other.A == A && other.B == B) || (other.B == A && other.A == B);
        }

        #endregion
    }
    ///<summary>
    /// Manages and constructs pair handlers from broad phase overlaps.
    ///</summary>
    public class NarrowPhase : MultithreadedProcessingStage
    {
        RawList<BroadPhaseOverlap> broadPhaseOverlaps; //Could be a reference passed into the system somehow too... use rawlist?
        ///<summary>
        /// Gets or sets the list of broad phase overlaps used by the narrow phase to manage pairs.
        ///</summary>
        public RawList<BroadPhaseOverlap> BroadPhaseOverlaps { get { return broadPhaseOverlaps; } set { broadPhaseOverlaps = value; } }

        Dictionary<BroadPhaseOverlap, NarrowPhasePair> overlapMapping = new Dictionary<BroadPhaseOverlap, NarrowPhasePair>();
        RawList<NarrowPhasePair> narrowPhasePairs = new RawList<NarrowPhasePair>();
        ///<summary>
        /// Gets the list of Pairs managed by the narrow phase.
        ///</summary>
        public ReadOnlyList<NarrowPhasePair> Pairs
        {
            get
            {
                return new ReadOnlyList<NarrowPhasePair>(narrowPhasePairs);
            }
        }

        ///<summary>
        /// Gets or sets the time step settings used by the narrow phase.
        ///</summary>
        public TimeStepSettings TimeStepSettings { get; set; }

        /// <summary>
        /// Gets or sets the solver into which the narrow phase will put solver updateables generated by narrow phase pairs.
        /// </summary>
        public Solver Solver { get; set; }

        ConcurrentDeque<NarrowPhasePair> newNarrowPhasePairs = new ConcurrentDeque<NarrowPhasePair>();


        ///<summary>
        /// Constructs a new narrow phase.
        ///</summary>
        ///<param name="timeStepSettings">Time step settings used by the narrow phase.</param>
        public NarrowPhase(TimeStepSettings timeStepSettings)
        {
            TimeStepSettings = timeStepSettings;
            updateBroadPhaseOverlapDelegate = UpdateBroadPhaseOverlap;
            Enabled = true;
        }

        ///<summary>
        /// Constructs a new narrow phase.
        ///</summary>
        ///<param name="timeStepSettings">Time step settings used by the narrow phase.</param>
        /// <param name="overlaps">Overlaps list used by the narrow phase to create pairs.</param>
        public NarrowPhase(TimeStepSettings timeStepSettings, RawList<BroadPhaseOverlap> overlaps)
            : this(timeStepSettings)
        {
            broadPhaseOverlaps = overlaps;
        }
        ///<summary>
        /// Constructs a new narrow phase.
        ///</summary>
        ///<param name="timeStepSettings">Time step settings used by the narrow phase.</param>
        /// <param name="overlaps">Overlaps list used by the narrow phase to create pairs.</param>
        /// <param name="threadManager">Thread manager used by the narrow phase.</param>
        public NarrowPhase(TimeStepSettings timeStepSettings, RawList<BroadPhaseOverlap> overlaps, IThreadManager threadManager)
            : this(timeStepSettings, overlaps)
        {
            ThreadManager = threadManager;
            AllowMultithreading = true;
        }

        Action<int> updateBroadPhaseOverlapDelegate;
        void UpdateBroadPhaseOverlap(int i)
        {
            BroadPhaseOverlap overlap = broadPhaseOverlaps.Elements[i];
            if (overlap.collisionRule < CollisionRule.NoNarrowPhasePair)
            {
                NarrowPhasePair narrowPhaseObject;
                //see if the overlap is already present in the narrow phase.
                if (!overlapMapping.TryGetValue(overlap, out narrowPhaseObject))
                {
                    //Create/enqueue based on collision table
                    narrowPhaseObject = NarrowPhaseHelper.GetPair(ref overlap);
                    if (narrowPhaseObject != null)
                    {
                        narrowPhaseObject.NarrowPhase = this;
                        //Add the new object to the 'todo' list.
                        //Technically, this doesn't need to be thread-safe when this is called from the sequential context.
                        //It's just bunched together for maintainability despite the slight performance hit.
                        newNarrowPhasePairs.Enqueue(narrowPhaseObject);
                    }
                }
                if (narrowPhaseObject != null)
                {

                    if (narrowPhaseObject.BroadPhaseOverlap.collisionRule < CollisionRule.NoNarrowPhaseUpdate)
                    {
                        narrowPhaseObject.UpdateCollision(TimeStepSettings.TimeStepDuration);
                        TryToAddFluxConstraint(narrowPhaseObject);
                    }
                    narrowPhaseObject.NeedsUpdate = false;
                }


            }
        }



        protected override void UpdateMultithreaded()
        {
            if (Solver != null)
                Solver.FluxUpdateables.Clear();

            ThreadManager.ForLoop(0, broadPhaseOverlaps.Count, updateBroadPhaseOverlapDelegate);

            //Remove stale objects.
            //TODO: This could benefit from a custom data structure (a tiny amount).
            //TODO: This could possibly be done with a computation spreading approach.
            //Problem: Consider a collision pair that has contacts one frame, and in the next, no longer even has a broad phase overlap.
            //It will receive no update, and the collision pair will still have a contact in it.
            //Collision solver will operate on permanently out of date information.
            //One possible solution requires that the user of the narrow phase object checks its age, and if it's out of date, ignore it.
            //In a subsequent frame, the system will get rid of it.  This has an advantage of lowering the (somewhat tiny) per frame cost of removal management.
            //Additionally, in highly chaotic situations where collisions are constantly being created/destroyed, spreading out the computations
            //smooths the work out a bit.


            //TODO:
            //Flush here?
            //Maybe, but not *only* here.
            //Character controller can fiddle with things in a later stage.

            RemoveStaleOverlaps();

            AddNewNarrowPhaseObjects();
        }


        protected override void UpdateSingleThreaded()
        {
            if (Solver != null)
                Solver.FluxUpdateables.Clear();

            int count = broadPhaseOverlaps.Count;
            for (int i = 0; i < count; i++)
            {
                UpdateBroadPhaseOverlap(i);
            }

            //TODO:
            //Flush here?
            //Maybe, but not *only* here.
            //Character controller can fiddle with things in a later stage.

            RemoveStaleOverlaps();

            AddNewNarrowPhaseObjects();


        }

        int staleLoopIndex;
        static float MaximumTraversedPairs = .1f;
        static float MaximumAttemptedSplits = .02f;
        int maximumAttemptedSplits;
        int maximumTraversedPairs;

        void RemoveStaleOverlaps()
        {
            //Remove stale objects.
            //TODO: This could possibly be done with a computation spreading approach.
            //Problem: Consider a collision pair that has contacts one frame, and in the next, no longer even has a broad phase overlap.
            //It will receive no update, and the collision pair will still have a contact in it.
            //Collision solver will operate on permanently out of date information.
            //One possible solution requires that the user of the narrow phase object checks its age, and if it's out of date, ignore it.
            //In a subsequent frame, the system will get rid of it.  This has an advantage of lowering the (somewhat tiny) per frame cost of removal management.
            //Additionally, in highly chaotic situations where collisions are constantly being created/destroyed, spreading out the computations
            //smooths the work out a bit.

            maximumAttemptedSplits = Math.Max(1, (int)(narrowPhasePairs.count * MaximumAttemptedSplits));
            maximumTraversedPairs = Math.Max(1, (int)(narrowPhasePairs.count * MaximumTraversedPairs));

            int attemptedSplits = 0;
            int traversedPairs = 0;
            while (attemptedSplits < maximumAttemptedSplits && traversedPairs < maximumTraversedPairs && narrowPhasePairs.count > 0)
            {
                if (--staleLoopIndex < 0 || staleLoopIndex >= narrowPhasePairs.count)
                    staleLoopIndex = narrowPhasePairs.count - 1; //Rather adding back upwards, just restart at the top.  The length can change.

                var pair = narrowPhasePairs.Elements[staleLoopIndex];
                //Overlap will not be refreshed if entries are inactive, but shouldn't remove narrow phase pair.
                if (pair.BroadPhaseOverlap.entryA.IsActive || pair.BroadPhaseOverlap.entryB.IsActive)
                {
                    if (pair.NeedsUpdate)
                    {
                        //The pair is stale!
                        narrowPhasePairs.FastRemoveAt(staleLoopIndex);
                        //Is the constraint is in the solver, we have to get rid of it.
                        //TODO: This may simplify some things in the cleanup of pairs.  They didn't previously have guarantees
                        //that it was not in the solver.
                        if (pair.constraint.SolverUpdateable.solver != null)
                        {
                            if (pair.constraint.SolverUpdateable.solver.FluxRemove(pair.constraint.SolverUpdateable))
                                attemptedSplits++;
                        }
                        OnRemovePair(pair);
                    }
                    else
                    {
                        //The pair isn't stale... but is the constraint?
                        //Check to make sure it hasn't already been removed before attempting to remove it.
                        if (pair.constraint.ShouldRemove && pair.constraint.SolverUpdateable.solver != null)
                        {
                            if (pair.constraint.SolverUpdateable.solver.FluxRemove(pair.constraint.SolverUpdateable))
                                attemptedSplits++;
                        }
                    }
                }
                traversedPairs++;
                pair.NeedsUpdate = true;

            }

            //for (int i = narrowPhasePairs.count - 1; i >= 0; i--)
            //{
            //    NarrowPhasePair narrowPhaseObject = narrowPhasePairs.Elements[i];
            //    //Overlap will not be refreshed if entries are inactive, but shouldn't remove narrow phase pair.
            //    if (narrowPhaseObject.BroadPhaseOverlap.entryA.IsActive || narrowPhaseObject.BroadPhaseOverlap.entryB.IsActive)
            //    {
            //        if (narrowPhaseObject.NeedsUpdate)
            //        {
            //            //The pair is stale!
            //            narrowPhasePairs.FastRemoveAt(i);
            //            //Is the constraint is in the solver, we have to get rid of it.
            //            //TODO: This may simplify some things in the cleanup of pairs.  They didn't previously have guarantees
            //            //that it was not in the solver.
            //            if (narrowPhaseObject.constraint.Constraint.solver != null)
            //                narrowPhaseObject.constraint.Constraint.solver.FluxRemove(narrowPhaseObject.constraint.Constraint);
            //            OnRemovePair(narrowPhaseObject);
            //        }
            //        else
            //        {
            //            //The pair isn't stale... but is the constraint?
            //            //Check to make sure it hasn't already been removed before attempting to remove it.
            //            if (narrowPhaseObject.constraint.ShouldRemove && narrowPhaseObject.constraint.Constraint.solver != null)
            //                narrowPhaseObject.constraint.Constraint.solver.FluxRemove(narrowPhaseObject.constraint.Constraint);
            //        }
            //    }
            //    narrowPhaseObject.NeedsUpdate = true;
            //}
        }

        void AddNewNarrowPhaseObjects()
        {
            //Add new narrow phase objects.  This will typically be a very tiny phase.
            NarrowPhasePair narrowPhaseObject;

            while (newNarrowPhasePairs.TryUnsafeDequeueFirst(out narrowPhaseObject))
            {
                narrowPhasePairs.Add(narrowPhaseObject);
                OnCreatePair(narrowPhaseObject);
            }
        }

        ///<summary>
        /// Gets the pair between two broad phase entries, if any.
        ///</summary>
        ///<param name="entryA">First entry in the pair.</param>
        ///<param name="entryB">Second entry in the pair.</param>
        ///<returns>The pair if it exists, null otherwise.</returns>
        public NarrowPhasePair GetPair(BroadPhaseEntry entryA, BroadPhaseEntry entryB)
        {
            NarrowPhasePair toReturn;
            overlapMapping.TryGetValue(new BroadPhaseOverlap(entryA, entryB), out toReturn);
            return toReturn;
        }

        protected void OnCreatePair(NarrowPhasePair pair)
        {
            overlapMapping.Add(pair.BroadPhaseOverlap, pair);
            pair.OnAddedToNarrowPhase();
            if (CreatingPair != null)
                CreatingPair(pair);
        }
        protected void OnRemovePair(NarrowPhasePair pair)
        {
            overlapMapping.Remove(pair.BroadPhaseOverlap);
            pair.CleanUp();
            pair.Factory.GiveBack(pair);
            if (RemovingPair != null)
                RemovingPair(pair);
        }
        ///<summary>
        /// Fires when the narrow phase creates a pair.
        ///</summary>
        public event Action<NarrowPhasePair> CreatingPair;
        ///<summary>
        /// Fires when the narrow phase removes a pair.
        ///</summary>
        public event Action<NarrowPhasePair> RemovingPair;

        ConcurrentDeque<SolverUpdateable> newSolverUpdateables = new ConcurrentDeque<SolverUpdateable>();
        ///<summary>
        /// Enqueues a solver updateable created by some pair for flushing into the solver later.
        ///</summary>
        ///<param name="pair">Pair owning the updateable..</param>
        public void NotifyUpdateableAdded(NarrowPhasePair pair)
        {
            var addedItem = pair.constraint;
            //Only enqueue the constraint for addition if it isn't already added.
            if (addedItem.SolverUpdateable.solver == null && Solver != null)
                newSolverUpdateables.Enqueue(addedItem.SolverUpdateable);
            //The updateable was added, so ensure that nothing tries to remove it!
            addedItem.ShouldRemove = false;
            //This does not add the added item to the flux updateables list.
            //That would needlessly lock- we already synchronized to enqueue to the 
            //new solver updateables, that's good enough.  The flux updateable will be
            //added during the flush.
        }
        ///<summary>
        /// Enqueues a solver updateable removed by some pair for flushing into the solver later.
        ///</summary>
        ///<param name="removedItem">Solver updateable to add.</param>
        public void NotifyUpdateableRemoved(NarrowPhasePairConstraint removedItem)
        {
            //Next time the narrow phase gets around to it, remove this object.
            //It may get added back in between now and then.  If it does, then ShouldRemove will be set to false, preventing it from being removed.
            removedItem.ShouldRemove = true;
        }

        /// <summary>
        /// Flushes the new solver updateables into the solver.
        /// They are 'flux' updateables, so this uses the solver's flux add method.
        /// </summary>
        public void FlushGeneratedSolverUpdateables()
        {
            //This method is only called when the constraint was not previously in the solver.
            //Further, the adder will also ensure that the new constraint's ShouldRemove was set to 
            //FALSE before it gets here.
            //So all this method has to do is flux add the new constraints.
            //Why do it here instead of in the main update?  Because this must be done sequentially; it modifies simulation islands.
            SolverUpdateable newConstraint;
            while (newSolverUpdateables.TryUnsafeDequeueFirst(out newConstraint))
            {
                //It is technically possible for a constraint to be added twice, if certain systems interfere.
                //The character controller is one such system.
                //We have to check the new constraint's solver status before adding it here.
                if (newConstraint.solver == null)
                {
                    Solver.FluxAdd(newConstraint);
                    //Have to add it to the flux updateables list too;
                    //the main update method only adds to the flux updateables list
                    //if the pair was already in the solver.  This avoids locking, too!
                    Solver.FluxUpdateables.Add(newConstraint);
                }
                //Note: we guaranteed the solver wasn't null before enqueuing.
            }
        }

        private SpinLock fluxLocker = new SpinLock();
        private void TryToAddFluxConstraint(NarrowPhasePair pair)
        {
            if (Solver != null && pair.constraint.SolverUpdateable.solver != null)// && pair.BroadPhaseOverlap.collisionRule < CollisionRule.NoSolver)
            {
                fluxLocker.Enter();
                Solver.FluxUpdateables.Add(pair.constraint.SolverUpdateable);
                fluxLocker.Exit();
            }
        }




        //The following are methods which can be used to split the narrow phase pair creation
        //from the pair update.  This can be helpful for some update orders where they cannot
        //be done simultaneously.  For performance, these would also need to implement 
        //multithreaded options.
        //void TryToAddOverlap(int i)
        //{
        //    BroadPhaseOverlap overlap = broadPhaseOverlaps.Elements[i];
        //    if (overlap.collisionRule < CollisionRule.NoNarrowPhasePair)
        //    {
        //        INarrowPhasePair narrowPhaseObject;
        //        //see if the overlap is already present in the narrow phase.
        //        if (!overlapMapping.TryGetValue(overlap, out narrowPhaseObject))
        //        {
        //            //Create/enqueue based on collision table
        //            narrowPhaseObject = NarrowPhaseHelper.GetPair(ref overlap);
        //            if (narrowPhaseObject != null)
        //            {
        //                narrowPhaseObject.NarrowPhase = this;
        //                //Add the new object to the 'todo' list.
        //                //Technically, this doesn't need to be thread-safe when this is called from the sequential context.
        //                //It's just bunched together for maintainability despite the slightly performance hit.
        //                newNarrowPhasePairs.Enqueue(narrowPhaseObject);
        //            }
        //        }
        //        if (narrowPhaseObject != null)
        //        {
        //            narrowPhaseObject.NeedsUpdate = false;  //This is hacky.
        //        }
        //    }
        //}

        //public void UpdatePairList()
        //{
        //    for (int i = 0; i < broadPhaseOverlaps.count; i++)
        //        TryToAddOverlap(i);

        //    if (narrowPhasePairs.Count < MultithreadedRemovalCutoff)
        //    {
        //        RemoveStaleOverlaps();
        //    }
        //    else
        //    {
        //        ThreadManager.ForLoop(0, narrowPhasePairs.Count, multithreadedRemovalLoopDelegate);
        //        INarrowPhasePair overlapToRemove;
        //        while (overlapsToRemove.TryUnsafeDequeueFirst(out overlapToRemove))
        //        {
        //            narrowPhasePairs[narrowPhasePairs.IndexOf(overlapToRemove)] = narrowPhasePairs[narrowPhasePairs.Count - 1];
        //            narrowPhasePairs.RemoveAt(narrowPhasePairs.Count - 1);
        //            OnRemovePair(overlapToRemove);
        //        }
        //    }


        //    AddNewNarrowPhaseObjects();
        //}

        //public void UpdatePairs()
        //{
        //    for (int i = 0; i < narrowPhasePairs.Count; i++)
        //    {
        //        if (narrowPhasePairs[i].BroadPhaseOverlap.collisionRule < CollisionRule.NoNarrowPhaseUpdate &&
        //            (narrowPhasePairs[i].BroadPhaseOverlap.entryA.IsActive || narrowPhasePairs[i].BroadPhaseOverlap.entryB.IsActive))
        //            narrowPhasePairs[i].UpdateCollision(TimeStepSettings.TimeStepDuration);
        //    }
        //}
    }
}
